<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PhiSch.org - STM32F4 Library: usb::stm32f4::UsbCoreViaSTM32F4 Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PhiSch.org - STM32F4 Library
   &#160;<span id="projectnumber">1fe2ae1+</span>
   </div>
   <div id="projectbrief">PhiSch.org - STM32F4 Lib</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>usb</b></li><li class="navelem"><b>stm32f4</b></li><li class="navelem"><a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html">UsbCoreViaSTM32F4</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#pri-static-attribs">Static Private Attributes</a> &#124;
<a href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">usb::stm32f4::UsbCoreViaSTM32F4 Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Driver for the STM32F4 USB Core.  
 <a href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_usb_core_via_s_t_m32_f4_8hpp_source.html">common/stm32f4/usb/include/usb/UsbCoreViaSTM32F4.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4_1_1irq__handler__s.html">irq_handler_s</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type definition for the USB Core IRQ handler table.  <a href="structusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4_1_1irq__handler__s.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4_1_1_power_and_clock_gating_control__s.html">PowerAndClockGatingControl_s</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type definition for access to the <code>PCGCCTL</code> register.  <a href="structusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4_1_1_power_and_clock_gating_control__s.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a461d8dd2f092d389b0b73da49968121d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#a461d8dd2f092d389b0b73da49968121d">DeviceMode_e</a> { <a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#a461d8dd2f092d389b0b73da49968121da7091795558dc7ddb1a64c40835b4381e">e_UsbDevice</a>, 
<a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#a461d8dd2f092d389b0b73da49968121da453ab40babc04abeb78339d85188e445">e_UsbHost</a>
 }</td></tr>
<tr class="memdesc:a461d8dd2f092d389b0b73da49968121d"><td class="mdescLeft">&#160;</td><td class="mdescRight">USB Hardware Mode (Host vs. Device).  <a href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#a461d8dd2f092d389b0b73da49968121d">More...</a><br /></td></tr>
<tr class="separator:a461d8dd2f092d389b0b73da49968121d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e49824b11b06f37955e30a72ccc2137"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#a1e49824b11b06f37955e30a72ccc2137">Interrupt_e</a> : uint32_t { <br />
&#160;&#160;<b>e_None</b> = 0, 
<a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#a1e49824b11b06f37955e30a72ccc2137a009f816fe144cd3232b5c32328e7d4da">e_ModeMismatch</a> = USB_OTG_GINTMSK_MMISM, 
<b>e_OnTheGo</b> = USB_OTG_GINTMSK_OTGINT, 
<b>e_StartOfFrame</b> = USB_OTG_GINTMSK_SOFM, 
<br />
&#160;&#160;<b>e_RxFifoNonEmpty</b> = USB_OTG_GINTMSK_RXFLVLM, 
<b>e_TxFifoEmpty</b> = USB_OTG_GINTMSK_NPTXFEM, 
<b>e_InNackEffective</b> = USB_OTG_GINTMSK_GINAKEFFM, 
<b>e_OutNackEffective</b> = USB_OTG_GINTMSK_GONAKEFFM, 
<br />
&#160;&#160;<b>e_EarlySuspend</b> = USB_OTG_GINTMSK_ESUSPM, 
<a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#a1e49824b11b06f37955e30a72ccc2137a87a77f40e07c5491a25b02e50a839f95">e_Suspend</a> = USB_OTG_GINTMSK_USBSUSPM, 
<b>e_Reset</b> = USB_OTG_GINTMSK_USBRST, 
<b>e_EnumerationDone</b> = USB_OTG_GINTMSK_ENUMDNEM, 
<br />
&#160;&#160;<b>e_IsoOutDropped</b> = USB_OTG_GINTMSK_ISOODRPM, 
<b>e_EndOfPeriodicFrame</b> = USB_OTG_GINTMSK_EOPFM, 
<b>e_EndpointMismatch</b> = USB_OTG_GINTMSK_EPMISM, 
<b>e_InEndpoint</b> = USB_OTG_GINTMSK_IEPINT, 
<br />
&#160;&#160;<b>e_OutEndpoint</b> = USB_OTG_GINTMSK_OEPINT, 
<b>e_IncomplIsoIn</b> = USB_OTG_GINTMSK_IISOIXFRM, 
<b>e_IncomplPeriodic</b> = USB_OTG_GINTMSK_PXFRM_IISOOXFRM, 
<b>e_FetchSuspended</b> = USB_OTG_GINTMSK_FSUSPM, 
<br />
&#160;&#160;<b>e_HostPort</b> = USB_OTG_GINTMSK_PRTIM, 
<b>e_HostChannel</b> = USB_OTG_GINTMSK_HCIM, 
<b>e_PeriodicTxEmpty</b> = USB_OTG_GINTMSK_PTXFEM, 
<b>e_ConnectorIdStatus</b> = USB_OTG_GINTMSK_CIDSCHGM, 
<br />
&#160;&#160;<b>e_Disconnected</b> = USB_OTG_GINTMSK_DISCINT, 
<a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#a1e49824b11b06f37955e30a72ccc2137a0239f25867ad86291c09415c7c601a6b">e_SessionRequest</a> = USB_OTG_GINTMSK_SRQIM, 
<b>e_WakeUpDetected</b> = USB_OTG_GINTMSK_WUIM
<br />
 }</td></tr>
<tr class="memdesc:a1e49824b11b06f37955e30a72ccc2137"><td class="mdescLeft">&#160;</td><td class="mdescRight">STM32F4 USB Core Interrupts.  <a href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#a1e49824b11b06f37955e30a72ccc2137">More...</a><br /></td></tr>
<tr class="separator:a1e49824b11b06f37955e30a72ccc2137"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5267c17d4f22f629d9638548b1e4e5d"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#a1e49824b11b06f37955e30a72ccc2137">usb::stm32f4::UsbCoreViaSTM32F4::Interrupt_e</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#ae5267c17d4f22f629d9638548b1e4e5d">Interrupt_t</a></td></tr>
<tr class="memdesc:ae5267c17d4f22f629d9638548b1e4e5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">STM32F4 USB Core Interrupts.  <a href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#ae5267c17d4f22f629d9638548b1e4e5d">More...</a><br /></td></tr>
<tr class="separator:ae5267c17d4f22f629d9638548b1e4e5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aab81593786bca1dcf9ece4dd3a26b9f8"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#aab81593786bca1dcf9ece4dd3a26b9f8">UsbCoreViaSTM32F4</a> (USB_OTG_GlobalTypeDef *const p_usbCore, intptr_t p_usbPowerCtrl, const uint32_t p_rxFifoSzInWords)</td></tr>
<tr class="memdesc:aab81593786bca1dcf9ece4dd3a26b9f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new <a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html" title="Driver for the STM32F4 USB Core.">UsbCoreViaSTM32F4</a> object.  <a href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#aab81593786bca1dcf9ece4dd3a26b9f8">More...</a><br /></td></tr>
<tr class="separator:aab81593786bca1dcf9ece4dd3a26b9f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a594977223b1c1710cc639be43340bb20"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#a594977223b1c1710cc639be43340bb20">~UsbCoreViaSTM32F4</a> ()</td></tr>
<tr class="memdesc:a594977223b1c1710cc639be43340bb20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy the <a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html" title="Driver for the STM32F4 USB Core.">UsbCoreViaSTM32F4</a> object.  <a href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#a594977223b1c1710cc639be43340bb20">More...</a><br /></td></tr>
<tr class="separator:a594977223b1c1710cc639be43340bb20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2f5988fbb4bc8037d6e647c0ad621dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#ac2f5988fbb4bc8037d6e647c0ad621dc">registerDevice</a> (const <a class="el" href="classusb_1_1stm32f4_1_1_usb_device_via_s_t_m32_f4.html">UsbDeviceViaSTM32F4</a> &amp;p_device)</td></tr>
<tr class="memdesc:ac2f5988fbb4bc8037d6e647c0ad621dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register USB Device Mode specific Callback Object.  <a href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#ac2f5988fbb4bc8037d6e647c0ad621dc">More...</a><br /></td></tr>
<tr class="separator:ac2f5988fbb4bc8037d6e647c0ad621dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10801276926fdbe30bc6e19edf021ca7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#a10801276926fdbe30bc6e19edf021ca7">unregisterDevice</a> (void)</td></tr>
<tr class="memdesc:a10801276926fdbe30bc6e19edf021ca7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregister USB Device Mode specific Callback Object.  <a href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#a10801276926fdbe30bc6e19edf021ca7">More...</a><br /></td></tr>
<tr class="separator:a10801276926fdbe30bc6e19edf021ca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e3ab532f29e7fbd2012726a0230585a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#a1e3ab532f29e7fbd2012726a0230585a">setupTxFifo</a> (const unsigned p_endpoint, const uint16_t p_fifoSzInWords) const</td></tr>
<tr class="memdesc:a1e3ab532f29e7fbd2012726a0230585a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set up the Tx FIFO for a given endpoint.  <a href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#a1e3ab532f29e7fbd2012726a0230585a">More...</a><br /></td></tr>
<tr class="separator:a1e3ab532f29e7fbd2012726a0230585a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a848efcb58b2d2687f61d17c059d7b7fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#a848efcb58b2d2687f61d17c059d7b7fc">flushTxFifo</a> (const uint8_t p_fifo) const</td></tr>
<tr class="memdesc:a848efcb58b2d2687f61d17c059d7b7fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flushes a given Tx FIFO.  <a href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#a848efcb58b2d2687f61d17c059d7b7fc">More...</a><br /></td></tr>
<tr class="separator:a848efcb58b2d2687f61d17c059d7b7fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27ee8785d34bcdfd8baa4ece56cc2118"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#a27ee8785d34bcdfd8baa4ece56cc2118">reset</a> (void) const</td></tr>
<tr class="memdesc:a27ee8785d34bcdfd8baa4ece56cc2118"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the USB Core.  <a href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#a27ee8785d34bcdfd8baa4ece56cc2118">More...</a><br /></td></tr>
<tr class="separator:a27ee8785d34bcdfd8baa4ece56cc2118"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98272b672a52b57951c4da8016041a5c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#a98272b672a52b57951c4da8016041a5c">setupMode</a> (const <a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#a461d8dd2f092d389b0b73da49968121d">DeviceMode_e</a> p_mode)</td></tr>
<tr class="memdesc:a98272b672a52b57951c4da8016041a5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set up the USB Mode (Host vs. Device).  <a href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#a98272b672a52b57951c4da8016041a5c">More...</a><br /></td></tr>
<tr class="separator:a98272b672a52b57951c4da8016041a5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2349d4598d6d451c2aa8636c4a80b82"><td class="memItemLeft" align="right" valign="top">constexpr intptr_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#ae2349d4598d6d451c2aa8636c4a80b82">getBaseAddr</a> (void) const</td></tr>
<tr class="memdesc:ae2349d4598d6d451c2aa8636c4a80b82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the Base Address of the USB Core's Registers.  <a href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#ae2349d4598d6d451c2aa8636c4a80b82">More...</a><br /></td></tr>
<tr class="separator:ae2349d4598d6d451c2aa8636c4a80b82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a879effe6fc9a6d31dceaff31cb1a3742"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#a879effe6fc9a6d31dceaff31cb1a3742">start</a> (void) const</td></tr>
<tr class="memdesc:a879effe6fc9a6d31dceaff31cb1a3742"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts the USB Core.  <a href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#a879effe6fc9a6d31dceaff31cb1a3742">More...</a><br /></td></tr>
<tr class="separator:a879effe6fc9a6d31dceaff31cb1a3742"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad126dd9920c327a10e2acfec238cb165"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#ad126dd9920c327a10e2acfec238cb165">stop</a> (void) const</td></tr>
<tr class="memdesc:ad126dd9920c327a10e2acfec238cb165"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops the USB Core.  <a href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#ad126dd9920c327a10e2acfec238cb165">More...</a><br /></td></tr>
<tr class="separator:ad126dd9920c327a10e2acfec238cb165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb95bfba04b9cf883313c87e166ae4af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#afb95bfba04b9cf883313c87e166ae4af">disableInterrupt</a> (const <a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#ae5267c17d4f22f629d9638548b1e4e5d">Interrupt_t</a> p_irq) const</td></tr>
<tr class="memdesc:afb95bfba04b9cf883313c87e166ae4af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables a given Interrupt.  <a href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#afb95bfba04b9cf883313c87e166ae4af">More...</a><br /></td></tr>
<tr class="separator:afb95bfba04b9cf883313c87e166ae4af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5cef0f5394faa019763935e4e915894"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#ab5cef0f5394faa019763935e4e915894">enableInterrupt</a> (const <a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#ae5267c17d4f22f629d9638548b1e4e5d">Interrupt_t</a> p_irq) const</td></tr>
<tr class="memdesc:ab5cef0f5394faa019763935e4e915894"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables a given Interrupt.  <a href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#ab5cef0f5394faa019763935e4e915894">More...</a><br /></td></tr>
<tr class="separator:ab5cef0f5394faa019763935e4e915894"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1c7fbbc13b1298102692d8793a78dbc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#af1c7fbbc13b1298102692d8793a78dbc">suspendPhy</a> (void) const</td></tr>
<tr class="memdesc:af1c7fbbc13b1298102692d8793a78dbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Suspends the USB PHY.  <a href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#af1c7fbbc13b1298102692d8793a78dbc">More...</a><br /></td></tr>
<tr class="separator:af1c7fbbc13b1298102692d8793a78dbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13dcc6cce6f7e58b1c33746878267060"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#a13dcc6cce6f7e58b1c33746878267060">resumePhy</a> (void) const</td></tr>
<tr class="memdesc:a13dcc6cce6f7e58b1c33746878267060"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resumes the USB PHY.  <a href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#a13dcc6cce6f7e58b1c33746878267060">More...</a><br /></td></tr>
<tr class="separator:a13dcc6cce6f7e58b1c33746878267060"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58929cd04b43a5450a6b633dd2953812"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#a58929cd04b43a5450a6b633dd2953812">handleIrq</a> (void) const</td></tr>
<tr class="memdesc:a58929cd04b43a5450a6b633dd2953812"><td class="mdescLeft">&#160;</td><td class="mdescRight">USB Core Interrupt Handler.  <a href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#a58929cd04b43a5450a6b633dd2953812">More...</a><br /></td></tr>
<tr class="separator:a58929cd04b43a5450a6b633dd2953812"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace29ee84691fd4a0c4af7fd04d763e5c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#ace29ee84691fd4a0c4af7fd04d763e5c">acknowledgeIrq</a> (const <a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#ae5267c17d4f22f629d9638548b1e4e5d">Interrupt_t</a> p_irq) const</td></tr>
<tr class="memdesc:ace29ee84691fd4a0c4af7fd04d763e5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acknowledge a given IRQ on the USB Core.  <a href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#ace29ee84691fd4a0c4af7fd04d763e5c">More...</a><br /></td></tr>
<tr class="separator:ace29ee84691fd4a0c4af7fd04d763e5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac011477e9750c892d37fb2cf9799f196"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#ac011477e9750c892d37fb2cf9799f196">getRxStatus</a> (void) const</td></tr>
<tr class="memdesc:ac011477e9750c892d37fb2cf9799f196"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read receive Status from Rx FIFO.  <a href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#ac011477e9750c892d37fb2cf9799f196">More...</a><br /></td></tr>
<tr class="separator:ac011477e9750c892d37fb2cf9799f196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eb52418a457e201740d6ed9dec5e6ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#a5eb52418a457e201740d6ed9dec5e6ed">setUsbTurnAroundTime</a> (const uint8_t p_turnaroundTime) const</td></tr>
<tr class="memdesc:a5eb52418a457e201740d6ed9dec5e6ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the USB Turn Around Time.  <a href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#a5eb52418a457e201740d6ed9dec5e6ed">More...</a><br /></td></tr>
<tr class="separator:a5eb52418a457e201740d6ed9dec5e6ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a1e43c1e3a3d20bb52d7b50566f17c9a4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#a1e43c1e3a3d20bb52d7b50566f17c9a4">initialize</a> (void) const</td></tr>
<tr class="memdesc:a1e43c1e3a3d20bb52d7b50566f17c9a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the USB Core.  <a href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#a1e43c1e3a3d20bb52d7b50566f17c9a4">More...</a><br /></td></tr>
<tr class="separator:a1e43c1e3a3d20bb52d7b50566f17c9a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a725cea85a05155fdde94de98fb148421"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#a725cea85a05155fdde94de98fb148421">terminate</a> (void) const</td></tr>
<tr class="memdesc:a725cea85a05155fdde94de98fb148421"><td class="mdescLeft">&#160;</td><td class="mdescRight">Terminate the USB Core.  <a href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#a725cea85a05155fdde94de98fb148421">More...</a><br /></td></tr>
<tr class="separator:a725cea85a05155fdde94de98fb148421"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:af6f22e2b93106289c2760f3a88e7e2a7"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4_1_1_power_and_clock_gating_control__s.html">usb::stm32f4::UsbCoreViaSTM32F4::PowerAndClockGatingControl_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#af6f22e2b93106289c2760f3a88e7e2a7">PowerAndClockGatingControl_t</a></td></tr>
<tr class="memdesc:af6f22e2b93106289c2760f3a88e7e2a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type definition for access to the <code>PCGCCTL</code> register.  <a href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#af6f22e2b93106289c2760f3a88e7e2a7">More...</a><br /></td></tr>
<tr class="separator:af6f22e2b93106289c2760f3a88e7e2a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a245b099fc65e32d0c6416efc9e86a10f"><td class="memItemLeft" align="right" valign="top">typedef void(usb::stm32f4::UsbCoreViaSTM32F4::*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#a245b099fc65e32d0c6416efc9e86a10f">irq_handler_fn</a>) () const</td></tr>
<tr class="memdesc:a245b099fc65e32d0c6416efc9e86a10f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type declaration for IRQ Handlers.  <a href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#a245b099fc65e32d0c6416efc9e86a10f">More...</a><br /></td></tr>
<tr class="separator:a245b099fc65e32d0c6416efc9e86a10f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8544f1184ec6c16d2a645c6c5228e41d"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4_1_1irq__handler__s.html">usb::stm32f4::UsbCoreViaSTM32F4::irq_handler_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#a8544f1184ec6c16d2a645c6c5228e41d">irq_handler_t</a></td></tr>
<tr class="memdesc:a8544f1184ec6c16d2a645c6c5228e41d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type definition for the USB Core IRQ handler table.  <a href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#a8544f1184ec6c16d2a645c6c5228e41d">More...</a><br /></td></tr>
<tr class="separator:a8544f1184ec6c16d2a645c6c5228e41d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:ad504f940f5d7f2768ad1a8f5e4fbf08d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#ad504f940f5d7f2768ad1a8f5e4fbf08d">disableInterrupt</a> (void) const</td></tr>
<tr class="memdesc:ad504f940f5d7f2768ad1a8f5e4fbf08d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable the USB Core Interrupts.  <a href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#ad504f940f5d7f2768ad1a8f5e4fbf08d">More...</a><br /></td></tr>
<tr class="separator:ad504f940f5d7f2768ad1a8f5e4fbf08d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac504032c4da3e513d22ae2e007bf03de"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#ac504032c4da3e513d22ae2e007bf03de">enableInterrupt</a> (void) const</td></tr>
<tr class="memdesc:ac504032c4da3e513d22ae2e007bf03de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the USB Core Interrupts.  <a href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#ac504032c4da3e513d22ae2e007bf03de">More...</a><br /></td></tr>
<tr class="separator:ac504032c4da3e513d22ae2e007bf03de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4576695f77ce72c047432c64f6578031"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#a4576695f77ce72c047432c64f6578031">stopPhy</a> (void) const</td></tr>
<tr class="memdesc:a4576695f77ce72c047432c64f6578031"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops the USB PHY.  <a href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#a4576695f77ce72c047432c64f6578031">More...</a><br /></td></tr>
<tr class="separator:a4576695f77ce72c047432c64f6578031"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59f81a6b799e1b8481602ee15bf7d49a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#a59f81a6b799e1b8481602ee15bf7d49a">startPhy</a> (void) const</td></tr>
<tr class="memdesc:a59f81a6b799e1b8481602ee15bf7d49a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops the USB PHY.  <a href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#a59f81a6b799e1b8481602ee15bf7d49a">More...</a><br /></td></tr>
<tr class="separator:a59f81a6b799e1b8481602ee15bf7d49a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3756904e729296d837da0a82e7bd0950"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#a3756904e729296d837da0a82e7bd0950">startTransceiver</a> (void) const</td></tr>
<tr class="memdesc:a3756904e729296d837da0a82e7bd0950"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts the USB Transceiver.  <a href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#a3756904e729296d837da0a82e7bd0950">More...</a><br /></td></tr>
<tr class="separator:a3756904e729296d837da0a82e7bd0950"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ba1c5a2bcb9cd300b2b5db66c888831"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#a4ba1c5a2bcb9cd300b2b5db66c888831">stopTransceiver</a> (void) const</td></tr>
<tr class="memdesc:a4ba1c5a2bcb9cd300b2b5db66c888831"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops the USB Transceiver.  <a href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#a4ba1c5a2bcb9cd300b2b5db66c888831">More...</a><br /></td></tr>
<tr class="separator:a4ba1c5a2bcb9cd300b2b5db66c888831"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af68bca9f4fedfd8c6e6c0db0ef68e32c"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#af68bca9f4fedfd8c6e6c0db0ef68e32c">setRxFifoSz</a> (const uint16_t p_rxFifoSzInWords) const</td></tr>
<tr class="memdesc:af68bca9f4fedfd8c6e6c0db0ef68e32c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set-up the Rx FIFO Size.  <a href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#af68bca9f4fedfd8c6e6c0db0ef68e32c">More...</a><br /></td></tr>
<tr class="separator:af68bca9f4fedfd8c6e6c0db0ef68e32c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57cd0acffdb9f21dbf95a9c56334b169"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#a57cd0acffdb9f21dbf95a9c56334b169">flushRxFifo</a> (void) const</td></tr>
<tr class="memdesc:a57cd0acffdb9f21dbf95a9c56334b169"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flushes the Rx FIFO.  <a href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#a57cd0acffdb9f21dbf95a9c56334b169">More...</a><br /></td></tr>
<tr class="separator:a57cd0acffdb9f21dbf95a9c56334b169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae455f459b1b34ab47f266732ffad9d4f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#ae455f459b1b34ab47f266732ffad9d4f">performReset</a> (const uint32_t p_reset) const</td></tr>
<tr class="memdesc:ae455f459b1b34ab47f266732ffad9d4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a partial reset of the USB Hardware.  <a href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#ae455f459b1b34ab47f266732ffad9d4f">More...</a><br /></td></tr>
<tr class="separator:ae455f459b1b34ab47f266732ffad9d4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc4704c1be0d6270734d7390c357fef2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#afc4704c1be0d6270734d7390c357fef2">setupModeInHw</a> (const <a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#a461d8dd2f092d389b0b73da49968121d">DeviceMode_e</a> p_mode) const</td></tr>
<tr class="memdesc:afc4704c1be0d6270734d7390c357fef2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set up the USB Mode in the Hardware.  <a href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#afc4704c1be0d6270734d7390c357fef2">More...</a><br /></td></tr>
<tr class="separator:afc4704c1be0d6270734d7390c357fef2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d8f2df39c69f1a59242eb537b4c0714"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#a9d8f2df39c69f1a59242eb537b4c0714">handleModeMismatchIrq</a> (void) const</td></tr>
<tr class="memdesc:a9d8f2df39c69f1a59242eb537b4c0714"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle the USB Mode Mismatch IRQ.  <a href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#a9d8f2df39c69f1a59242eb537b4c0714">More...</a><br /></td></tr>
<tr class="separator:a9d8f2df39c69f1a59242eb537b4c0714"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a6ed2d364d4e3653db2d10847aa098f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#a3a6ed2d364d4e3653db2d10847aa098f">handleOtgIrq</a> (void) const</td></tr>
<tr class="memdesc:a3a6ed2d364d4e3653db2d10847aa098f"><td class="mdescLeft">&#160;</td><td class="mdescRight">USB Core On-the-Go (OTG) Interrupt Handler.  <a href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#a3a6ed2d364d4e3653db2d10847aa098f">More...</a><br /></td></tr>
<tr class="separator:a3a6ed2d364d4e3653db2d10847aa098f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5061e18cc35db5fa85a8b421db06256e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#a5061e18cc35db5fa85a8b421db06256e">handleSessionRequest</a> (void) const</td></tr>
<tr class="memdesc:a5061e18cc35db5fa85a8b421db06256e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle the <em>Session Request</em> IRQ.  <a href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#a5061e18cc35db5fa85a8b421db06256e">More...</a><br /></td></tr>
<tr class="separator:a5061e18cc35db5fa85a8b421db06256e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7167cab2124f0f210442c42ae94c2d63"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#a7167cab2124f0f210442c42ae94c2d63">handleSessionEnd</a> (void) const</td></tr>
<tr class="memdesc:a7167cab2124f0f210442c42ae94c2d63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle the <em>Session End</em> IRQ.  <a href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#a7167cab2124f0f210442c42ae94c2d63">More...</a><br /></td></tr>
<tr class="separator:a7167cab2124f0f210442c42ae94c2d63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1ecb4f63a2f8c68f00983b0458f1b43"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#ab1ecb4f63a2f8c68f00983b0458f1b43">wakeUpDetectedIrq</a> (void) const</td></tr>
<tr class="memdesc:ab1ecb4f63a2f8c68f00983b0458f1b43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle the <em>Wake-up Detected</em> IRQ.  <a href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#ab1ecb4f63a2f8c68f00983b0458f1b43">More...</a><br /></td></tr>
<tr class="separator:ab1ecb4f63a2f8c68f00983b0458f1b43"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:ab47132f80040198855c4e6145e026ccb"><td class="memItemLeft" align="right" valign="top"><a id="ab47132f80040198855c4e6145e026ccb"></a>
USB_OTG_GlobalTypeDef *const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#ab47132f80040198855c4e6145e026ccb">m_usbCore</a></td></tr>
<tr class="memdesc:ab47132f80040198855c4e6145e026ccb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference to the USB Core's Registers. <br /></td></tr>
<tr class="separator:ab47132f80040198855c4e6145e026ccb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59baddb474530bb2cab74214fb8049eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#af6f22e2b93106289c2760f3a88e7e2a7">PowerAndClockGatingControl_t</a> *const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#a59baddb474530bb2cab74214fb8049eb">m_usbPwrCtrl</a></td></tr>
<tr class="memdesc:a59baddb474530bb2cab74214fb8049eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference to the USB Core's <code>PCGCCTL</code> Register.  <a href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#a59baddb474530bb2cab74214fb8049eb">More...</a><br /></td></tr>
<tr class="separator:a59baddb474530bb2cab74214fb8049eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e2241f87f7136e1bc5551a55e8aedc8"><td class="memItemLeft" align="right" valign="top">const uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#a3e2241f87f7136e1bc5551a55e8aedc8">m_rxFifoSzInWords</a></td></tr>
<tr class="memdesc:a3e2241f87f7136e1bc5551a55e8aedc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">USB Rx FIFO Size in Words.  <a href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#a3e2241f87f7136e1bc5551a55e8aedc8">More...</a><br /></td></tr>
<tr class="separator:a3e2241f87f7136e1bc5551a55e8aedc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11e1d40e93b17b8a42aba11c8035e953"><td class="memItemLeft" align="right" valign="top"><a id="a11e1d40e93b17b8a42aba11c8035e953"></a>
const <a class="el" href="classusb_1_1stm32f4_1_1_usb_device_via_s_t_m32_f4.html">UsbDeviceViaSTM32F4</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#a11e1d40e93b17b8a42aba11c8035e953">m_usbDevice</a></td></tr>
<tr class="memdesc:a11e1d40e93b17b8a42aba11c8035e953"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference to the USB Device Mode Callback Object. <br /></td></tr>
<tr class="separator:a11e1d40e93b17b8a42aba11c8035e953"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab60951ecb3cb9835bc4764e9b62b726a"><td class="memItemLeft" align="right" valign="top"><a id="ab60951ecb3cb9835bc4764e9b62b726a"></a>
<a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#a461d8dd2f092d389b0b73da49968121d">DeviceMode_e</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#ab60951ecb3cb9835bc4764e9b62b726a">m_mode</a></td></tr>
<tr class="memdesc:ab60951ecb3cb9835bc4764e9b62b726a"><td class="mdescLeft">&#160;</td><td class="mdescRight">USB Mode (Host vs. Device Mode). <br /></td></tr>
<tr class="separator:ab60951ecb3cb9835bc4764e9b62b726a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-attribs"></a>
Static Private Attributes</h2></td></tr>
<tr class="memitem:a7dc7042ac84afd01fb3143696a203efa"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#a8544f1184ec6c16d2a645c6c5228e41d">irq_handler_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#a7dc7042ac84afd01fb3143696a203efa">m_irq_handler</a> []</td></tr>
<tr class="memdesc:a7dc7042ac84afd01fb3143696a203efa"><td class="mdescLeft">&#160;</td><td class="mdescRight">USB Core Interrupt Handlers.  <a href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#a7dc7042ac84afd01fb3143696a203efa">More...</a><br /></td></tr>
<tr class="separator:a7dc7042ac84afd01fb3143696a203efa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a358f93ffcad0f759452778f91ff516af"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#a8544f1184ec6c16d2a645c6c5228e41d">irq_handler_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#a358f93ffcad0f759452778f91ff516af">m_otgirq_handler</a> []</td></tr>
<tr class="memdesc:a358f93ffcad0f759452778f91ff516af"><td class="mdescLeft">&#160;</td><td class="mdescRight">USB Core On-the-Go (OTG) Interrupt Handlers.  <a href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#a358f93ffcad0f759452778f91ff516af">More...</a><br /></td></tr>
<tr class="separator:a358f93ffcad0f759452778f91ff516af"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Driver for the STM32F4 USB Core. </p>
<p>Class that encapsulates the operation of the STM32F4's USB On-the-Go (OTG) Core. This is code common to both Device and Host mode operation.</p>
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000001">Bug:</a></b></dt><dd>Currently, the <a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#aab81593786bca1dcf9ece4dd3a26b9f8" title="Construct a new UsbCoreViaSTM32F4 object.">UsbCoreViaSTM32F4</a> class only supports USB Device Mode.</dd></dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ae5267c17d4f22f629d9638548b1e4e5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5267c17d4f22f629d9638548b1e4e5d">&#9670;&nbsp;</a></span>Interrupt_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#a1e49824b11b06f37955e30a72ccc2137">usb::stm32f4::UsbCoreViaSTM32F4::Interrupt_e</a> <a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#ae5267c17d4f22f629d9638548b1e4e5d">usb::stm32f4::UsbCoreViaSTM32F4::Interrupt_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>STM32F4 USB Core Interrupts. </p>
<p>This enum defines the possible STM32F4 USB Core Interrupts as described by the Datasheet for the <code>GINTMSK</code> as well as for the <code>GINTSTS</code> Registers.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#a7dc7042ac84afd01fb3143696a203efa" title="USB Core Interrupt Handlers.">m_irq_handler</a> </dd>
<dd>
<a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#a58929cd04b43a5450a6b633dd2953812" title="USB Core Interrupt Handler.">handleIrq</a> </dd></dl>

</div>
</div>
<a id="a245b099fc65e32d0c6416efc9e86a10f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a245b099fc65e32d0c6416efc9e86a10f">&#9670;&nbsp;</a></span>irq_handler_fn</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(usb::stm32f4::UsbCoreViaSTM32F4::* usb::stm32f4::UsbCoreViaSTM32F4::irq_handler_fn) () const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Type declaration for IRQ Handlers. </p>
<p>IRQ handlers are Pointers to Member Functions. This typedef is declared for convenience when using the pointers. </p>

</div>
</div>
<a id="a8544f1184ec6c16d2a645c6c5228e41d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8544f1184ec6c16d2a645c6c5228e41d">&#9670;&nbsp;</a></span>irq_handler_t</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4_1_1irq__handler__s.html">usb::stm32f4::UsbCoreViaSTM32F4::irq_handler_s</a> <a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#a8544f1184ec6c16d2a645c6c5228e41d">usb::stm32f4::UsbCoreViaSTM32F4::irq_handler_t</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Type definition for the USB Core IRQ handler table. </p>
<p>Type definition for the various IRQ handler tables used in <a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#aab81593786bca1dcf9ece4dd3a26b9f8" title="Construct a new UsbCoreViaSTM32F4 object.">UsbCoreViaSTM32F4</a>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#a7dc7042ac84afd01fb3143696a203efa" title="USB Core Interrupt Handlers.">m_irq_handler</a> </dd>
<dd>
<a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#a358f93ffcad0f759452778f91ff516af" title="USB Core On-the-Go (OTG) Interrupt Handlers.">m_otgirq_handler</a> </dd></dl>

</div>
</div>
<a id="af6f22e2b93106289c2760f3a88e7e2a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6f22e2b93106289c2760f3a88e7e2a7">&#9670;&nbsp;</a></span>PowerAndClockGatingControl_t</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4_1_1_power_and_clock_gating_control__s.html">usb::stm32f4::UsbCoreViaSTM32F4::PowerAndClockGatingControl_s</a> <a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#af6f22e2b93106289c2760f3a88e7e2a7">usb::stm32f4::UsbCoreViaSTM32F4::PowerAndClockGatingControl_t</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Type definition for access to the <code>PCGCCTL</code> register. </p>
<p>Because the register doesn't seem to be declared in the ST-provided C-style header files, we're setting up our own type definition here. </p>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a461d8dd2f092d389b0b73da49968121d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a461d8dd2f092d389b0b73da49968121d">&#9670;&nbsp;</a></span>DeviceMode_e</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#a461d8dd2f092d389b0b73da49968121d">usb::stm32f4::UsbCoreViaSTM32F4::DeviceMode_e</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>USB Hardware Mode (Host vs. Device). </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#a98272b672a52b57951c4da8016041a5c" title="Set up the USB Mode (Host vs. Device).">setupMode</a> </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a461d8dd2f092d389b0b73da49968121da7091795558dc7ddb1a64c40835b4381e"></a>e_UsbDevice&#160;</td><td class="fielddoc"><p>USB Device Mode. </p>
</td></tr>
<tr><td class="fieldname"><a id="a461d8dd2f092d389b0b73da49968121da453ab40babc04abeb78339d85188e445"></a>e_UsbHost&#160;</td><td class="fielddoc"><p>USB Host Mode. </p>
</td></tr>
</table>

</div>
</div>
<a id="a1e49824b11b06f37955e30a72ccc2137"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e49824b11b06f37955e30a72ccc2137">&#9670;&nbsp;</a></span>Interrupt_e</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#a1e49824b11b06f37955e30a72ccc2137">usb::stm32f4::UsbCoreViaSTM32F4::Interrupt_e</a> : uint32_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>STM32F4 USB Core Interrupts. </p>
<p>This enum defines the possible STM32F4 USB Core Interrupts as described by the Datasheet for the <code>GINTMSK</code> as well as for the <code>GINTSTS</code> Registers.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#a7dc7042ac84afd01fb3143696a203efa" title="USB Core Interrupt Handlers.">m_irq_handler</a> </dd>
<dd>
<a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#a58929cd04b43a5450a6b633dd2953812" title="USB Core Interrupt Handler.">handleIrq</a> </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a1e49824b11b06f37955e30a72ccc2137a009f816fe144cd3232b5c32328e7d4da"></a>e_ModeMismatch&#160;</td><td class="fielddoc"><p>USB Mode Mismatch Interrupt. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#a9d8f2df39c69f1a59242eb537b4c0714" title="Handle the USB Mode Mismatch IRQ.">handleModeMismatchIrq</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="a1e49824b11b06f37955e30a72ccc2137a87a77f40e07c5491a25b02e50a839f95"></a>e_Suspend&#160;</td><td class="fielddoc"><p>USB Suspend IRQ. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classusb_1_1stm32f4_1_1_usb_device_via_s_t_m32_f4.html#aa20e02b1d294cecb3caebce000279450" title="Handles the USB Suspend IRQ.">usb::stm32f4::UsbDeviceViaSTM32F4::handleUsbSuspendIrq</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="a1e49824b11b06f37955e30a72ccc2137a0239f25867ad86291c09415c7c601a6b"></a>e_SessionRequest&#160;</td><td class="fielddoc"><p>Session Request IRQ. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#a5061e18cc35db5fa85a8b421db06256e" title="Handle the Session Request IRQ.">handleSessionRequest</a> </dd></dl>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aab81593786bca1dcf9ece4dd3a26b9f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab81593786bca1dcf9ece4dd3a26b9f8">&#9670;&nbsp;</a></span>UsbCoreViaSTM32F4()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr usb::stm32f4::UsbCoreViaSTM32F4::UsbCoreViaSTM32F4 </td>
          <td>(</td>
          <td class="paramtype">USB_OTG_GlobalTypeDef *const&#160;</td>
          <td class="paramname"><em>p_usbCore</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">intptr_t&#160;</td>
          <td class="paramname"><em>p_usbPowerCtrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>p_rxFifoSzInWords</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a new <a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html" title="Driver for the STM32F4 USB Core.">UsbCoreViaSTM32F4</a> object. </p>
<p>This constructor is used from the helper sub-class sets up the references to the Hardware addresses based on the desired USB Mode (High Speed vs. Full Speed).</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4_from_address_pointer_t.html">UsbCoreViaSTM32F4FromAddressPointerT</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_usbCore</td><td>Pointer to USB Core's Registers. </td></tr>
    <tr><td class="paramname">p_usbPowerCtrl</td><td>Pointer to USB Core's <code>PCGCCTL</code> Register. </td></tr>
    <tr><td class="paramname">p_rxFifoSzInWords</td><td>USB Rx FIFO Size in Words. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a594977223b1c1710cc639be43340bb20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a594977223b1c1710cc639be43340bb20">&#9670;&nbsp;</a></span>~UsbCoreViaSTM32F4()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual usb::stm32f4::UsbCoreViaSTM32F4::~UsbCoreViaSTM32F4 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroy the <a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html" title="Driver for the STM32F4 USB Core.">UsbCoreViaSTM32F4</a> object. </p>
<p>Virtual because the class is intended to be sub-classed.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4_from_address_pointer_t.html">UsbCoreViaSTM32F4FromAddressPointerT</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ace29ee84691fd4a0c4af7fd04d763e5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace29ee84691fd4a0c4af7fd04d763e5c">&#9670;&nbsp;</a></span>acknowledgeIrq()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void usb::stm32f4::UsbCoreViaSTM32F4::acknowledgeIrq </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#ae5267c17d4f22f629d9638548b1e4e5d">Interrupt_t</a>&#160;</td>
          <td class="paramname"><em>p_irq</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Acknowledge a given IRQ on the USB Core. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_irq</td><td>IRQ that is to be acknowledged. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afb95bfba04b9cf883313c87e166ae4af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb95bfba04b9cf883313c87e166ae4af">&#9670;&nbsp;</a></span>disableInterrupt() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void usb::stm32f4::UsbCoreViaSTM32F4::disableInterrupt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#ae5267c17d4f22f629d9638548b1e4e5d">Interrupt_t</a>&#160;</td>
          <td class="paramname"><em>p_irq</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disables a given Interrupt. </p>
<p>Masks the given Interrupt in the <code>GINTMSK</code> register.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_irq</td><td>Interrupt to be disabled. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad504f940f5d7f2768ad1a8f5e4fbf08d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad504f940f5d7f2768ad1a8f5e4fbf08d">&#9670;&nbsp;</a></span>disableInterrupt() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void usb::stm32f4::UsbCoreViaSTM32F4::disableInterrupt </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disable the USB Core Interrupts. </p>
<p>Masks all USB Core IRQs by setting the <code>GINT</code> Bit in the <code>GAHBCFG</code> register. </p>

</div>
</div>
<a id="ab5cef0f5394faa019763935e4e915894"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5cef0f5394faa019763935e4e915894">&#9670;&nbsp;</a></span>enableInterrupt() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void usb::stm32f4::UsbCoreViaSTM32F4::enableInterrupt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#ae5267c17d4f22f629d9638548b1e4e5d">Interrupt_t</a>&#160;</td>
          <td class="paramname"><em>p_irq</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enables a given Interrupt. </p>
<p>Unmasks the given Interrupt in the <code>GINTMSK</code> register.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_irq</td><td>Interrupt to be enabled. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac504032c4da3e513d22ae2e007bf03de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac504032c4da3e513d22ae2e007bf03de">&#9670;&nbsp;</a></span>enableInterrupt() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void usb::stm32f4::UsbCoreViaSTM32F4::enableInterrupt </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enables the USB Core Interrupts. </p>
<p>Masks all USB Core IRQs by setting the <code>GINT</code> Bit in the <code>GAHBCFG</code> register.</p>
<dl class="section attention"><dt>Attention</dt><dd>Before unmasking the Interrupts, all pending IRQs are cleared. </dd></dl>

</div>
</div>
<a id="a57cd0acffdb9f21dbf95a9c56334b169"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57cd0acffdb9f21dbf95a9c56334b169">&#9670;&nbsp;</a></span>flushRxFifo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void usb::stm32f4::UsbCoreViaSTM32F4::flushRxFifo </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flushes the Rx FIFO. </p>
<p>Flushes the Rx FIFO by performing the <code>RXFFLSH</code> Reset via <a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#ae455f459b1b34ab47f266732ffad9d4f" title="Performs a partial reset of the USB Hardware.">performReset</a>. </p>

</div>
</div>
<a id="a848efcb58b2d2687f61d17c059d7b7fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a848efcb58b2d2687f61d17c059d7b7fc">&#9670;&nbsp;</a></span>flushTxFifo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void usb::stm32f4::UsbCoreViaSTM32F4::flushTxFifo </td>
          <td>(</td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>p_fifo</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flushes a given Tx FIFO. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_fifo</td><td>Index of Tx FIFO to be flushed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae2349d4598d6d451c2aa8636c4a80b82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2349d4598d6d451c2aa8636c4a80b82">&#9670;&nbsp;</a></span>getBaseAddr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr intptr_t usb::stm32f4::UsbCoreViaSTM32F4::getBaseAddr </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the Base Address of the USB Core's Registers. </p>
<p>Used by the Mode-dependent class to figure out the Base Address of the Mode-specific registers.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classusb_1_1stm32f4_1_1_usb_device_via_s_t_m32_f4.html">UsbDeviceViaSTM32F4</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>constexpr intptr_t Base Address of the USB Core Registers. </dd></dl>

</div>
</div>
<a id="ac011477e9750c892d37fb2cf9799f196"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac011477e9750c892d37fb2cf9799f196">&#9670;&nbsp;</a></span>getRxStatus()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t usb::stm32f4::UsbCoreViaSTM32F4::getRxStatus </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read receive Status from Rx FIFO. </p>
<p>The reads the USB Device's Rx FIFO Receive Status via the <code>GRXSTSP</code> register. This means the status is read and removed (pop-ed) from the FIFO. </p>

</div>
</div>
<a id="a58929cd04b43a5450a6b633dd2953812"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58929cd04b43a5450a6b633dd2953812">&#9670;&nbsp;</a></span>handleIrq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void usb::stm32f4::UsbCoreViaSTM32F4::handleIrq </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>USB Core Interrupt Handler. </p>
<p>Handles the USB On-the-Go (OTG) Core's Interrupts as signalled in the <code>GINTSTS</code> register. This handler will process the interrupts valid for both Host- and Device-Mode.</p>
<p>If a valid USB Device Callback is registered in <a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#a11e1d40e93b17b8a42aba11c8035e953" title="Reference to the USB Device Mode Callback Object.">m_usbDevice</a>, then further processing of Device-specific interrupts is handled in the <a class="el" href="classusb_1_1stm32f4_1_1_usb_device_via_s_t_m32_f4.html">UsbDeviceViaSTM32F4</a> object.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#a7dc7042ac84afd01fb3143696a203efa" title="USB Core Interrupt Handlers.">m_irq_handler</a> </dd></dl>

</div>
</div>
<a id="a9d8f2df39c69f1a59242eb537b4c0714"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d8f2df39c69f1a59242eb537b4c0714">&#9670;&nbsp;</a></span>handleModeMismatchIrq()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void usb::stm32f4::UsbCoreViaSTM32F4::handleModeMismatchIrq </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handle the USB Mode Mismatch IRQ. </p>
<p>According to the Data Sheet, this interrupt is triggered when the Software attempts to access a Host-mode register when operating in Device-Mode and vice-versa.</p>
<p>In Debug Mode, this method will <code>assert()</code> and thus serves as a debugging aid.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#a1e49824b11b06f37955e30a72ccc2137a009f816fe144cd3232b5c32328e7d4da" title="USB Mode Mismatch Interrupt.">e_ModeMismatch</a> </dd></dl>

</div>
</div>
<a id="a3a6ed2d364d4e3653db2d10847aa098f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a6ed2d364d4e3653db2d10847aa098f">&#9670;&nbsp;</a></span>handleOtgIrq()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void usb::stm32f4::UsbCoreViaSTM32F4::handleOtgIrq </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>USB Core On-the-Go (OTG) Interrupt Handler. </p>
<p>Handles the USB On-the-Go (OTG) Core's Interrupts as signalled in the <code>GOTGINT</code> register.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#a358f93ffcad0f759452778f91ff516af" title="USB Core On-the-Go (OTG) Interrupt Handlers.">m_otgirq_handler</a> </dd></dl>

</div>
</div>
<a id="a7167cab2124f0f210442c42ae94c2d63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7167cab2124f0f210442c42ae94c2d63">&#9670;&nbsp;</a></span>handleSessionEnd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void usb::stm32f4::UsbCoreViaSTM32F4::handleSessionEnd </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handle the <em>Session End</em> IRQ. </p>
<p>In USB Device Mode, this interrupt is triggered when the host is disconnected, e.g. when the USB cable is unplugged.</p>
<dl class="section attention"><dt>Attention</dt><dd>This will re-enable IRQs and unmask the <em>Session Request</em> IRQ. This is needed so the Application can react if the device is plugged back in. </dd></dl>

</div>
</div>
<a id="a5061e18cc35db5fa85a8b421db06256e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5061e18cc35db5fa85a8b421db06256e">&#9670;&nbsp;</a></span>handleSessionRequest()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void usb::stm32f4::UsbCoreViaSTM32F4::handleSessionRequest </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handle the <em>Session Request</em> IRQ. </p>
<p>In USB Device Mode, this is triggered when the Device is connected to a USB Host.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#a7dc7042ac84afd01fb3143696a203efa" title="USB Core Interrupt Handlers.">m_irq_handler</a> </dd>
<dd>
<a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#a1e49824b11b06f37955e30a72ccc2137a0239f25867ad86291c09415c7c601a6b" title="Session Request IRQ.">e_SessionRequest</a> </dd></dl>

</div>
</div>
<a id="a1e43c1e3a3d20bb52d7b50566f17c9a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e43c1e3a3d20bb52d7b50566f17c9a4">&#9670;&nbsp;</a></span>initialize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void usb::stm32f4::UsbCoreViaSTM32F4::initialize </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize the USB Core. </p>

</div>
</div>
<a id="ae455f459b1b34ab47f266732ffad9d4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae455f459b1b34ab47f266732ffad9d4f">&#9670;&nbsp;</a></span>performReset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void usb::stm32f4::UsbCoreViaSTM32F4::performReset </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>p_reset</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a partial reset of the USB Hardware. </p>
<p>Performs a partial reset of the USB Hardware via the <code>GRSTCTL</code> register.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_reset</td><td>Type of reset to be performed. Must be one of the allowed reset types as defined in the hardware documentation of the <code>GRSTCTL</code> register.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section attention"><dt>Attention</dt><dd>This method blocks until the reset is complete by waiting for the <code>AHBIDL</code> bit in the <code>GRSTCTL</code> register to be set.</dd></dl>
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000002">Bug:</a></b></dt><dd>This method should probably use an enum to define the allowed types of reset.</dd></dl>

</div>
</div>
<a id="ac2f5988fbb4bc8037d6e647c0ad621dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2f5988fbb4bc8037d6e647c0ad621dc">&#9670;&nbsp;</a></span>registerDevice()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void usb::stm32f4::UsbCoreViaSTM32F4::registerDevice </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classusb_1_1stm32f4_1_1_usb_device_via_s_t_m32_f4.html">UsbDeviceViaSTM32F4</a> &amp;&#160;</td>
          <td class="paramname"><em>p_device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Register USB Device Mode specific Callback Object. </p>
<p>This method is only allowed to be called if no previous object has been registered before.</p>
<p>While this would not be required, the pattern is used to discourage calls that would not be needed otherwise.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_device</td><td><a class="el" href="classusb_1_1stm32f4_1_1_usb_device_via_s_t_m32_f4.html">UsbDeviceViaSTM32F4</a> object to be used as a callback.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#a10801276926fdbe30bc6e19edf021ca7" title="Unregister USB Device Mode specific Callback Object.">unregisterDevice</a> </dd></dl>

</div>
</div>
<a id="a27ee8785d34bcdfd8baa4ece56cc2118"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27ee8785d34bcdfd8baa4ece56cc2118">&#9670;&nbsp;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void usb::stm32f4::UsbCoreViaSTM32F4::reset </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets the USB Core. </p>
<p>Performs a reset of the USB Core's Hardware. </p>

</div>
</div>
<a id="a13dcc6cce6f7e58b1c33746878267060"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13dcc6cce6f7e58b1c33746878267060">&#9670;&nbsp;</a></span>resumePhy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void usb::stm32f4::UsbCoreViaSTM32F4::resumePhy </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resumes the USB PHY. </p>
<p>Resumes the USB PHY by enabling the clocks via the <code>PCGCCTL</code> register.</p>
<dl class="section attention"><dt>Attention</dt><dd>This method blocks until the Hardware reports the PHY as actually running via the <code>PCGCCTL</code> register.</dd></dl>
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000004">Bug:</a></b></dt><dd>I think the <code>STPPCLK</code> and the <code>GATEHCLK</code> should be separated as only the <code>STPPCLK</code> bit should be set when a <em>USB Suspend</em> IRQ ( <a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#a1e49824b11b06f37955e30a72ccc2137a87a77f40e07c5491a25b02e50a839f95" title="USB Suspend IRQ.">e_Suspend</a> ) occurs.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#af1c7fbbc13b1298102692d8793a78dbc" title="Suspends the USB PHY.">suspendPhy</a> </dd></dl>

</div>
</div>
<a id="af68bca9f4fedfd8c6e6c0db0ef68e32c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af68bca9f4fedfd8c6e6c0db0ef68e32c">&#9670;&nbsp;</a></span>setRxFifoSz()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void usb::stm32f4::UsbCoreViaSTM32F4::setRxFifoSz </td>
          <td>(</td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>p_rxFifoSzInWords</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set-up the Rx FIFO Size. </p>
<p>Sets up the Rx FIFO size in the <code>GRXFSIZ</code> register.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_rxFifoSzInWords</td><td>Rx FIFO Size in Words. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The <code>p_rxFifoSzInWords</code> must be between 16 and 256 words. </dd></dl>

</div>
</div>
<a id="a98272b672a52b57951c4da8016041a5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98272b672a52b57951c4da8016041a5c">&#9670;&nbsp;</a></span>setupMode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void usb::stm32f4::UsbCoreViaSTM32F4::setupMode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#a461d8dd2f092d389b0b73da49968121d">DeviceMode_e</a>&#160;</td>
          <td class="paramname"><em>p_mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set up the USB Mode (Host vs. Device). </p>
<p>Used by the Mode-dependent class to set up the USB Mode in the STM32F4 Hardware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_mode</td><td>USB MOde (Host vs. Device).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classusb_1_1stm32f4_1_1_usb_device_via_s_t_m32_f4.html">UsbDeviceViaSTM32F4</a> </dd>
<dd>
<a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#afc4704c1be0d6270734d7390c357fef2" title="Set up the USB Mode in the Hardware.">setupModeInHw</a> </dd></dl>

</div>
</div>
<a id="afc4704c1be0d6270734d7390c357fef2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc4704c1be0d6270734d7390c357fef2">&#9670;&nbsp;</a></span>setupModeInHw()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void usb::stm32f4::UsbCoreViaSTM32F4::setupModeInHw </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#a461d8dd2f092d389b0b73da49968121d">DeviceMode_e</a>&#160;</td>
          <td class="paramname"><em>p_mode</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set up the USB Mode in the Hardware. </p>
<p>This method will set up the requested USB Mode (Host or Device) in the USB Core Hardware.</p>
<p>In case of Device Mode, the method will</p><ul>
<li>Enable Vbus sensing by setting the <code>VBUSBSEN</code> Bit in the <code>GCCFG</code> register.</li>
<li>Force Device Mode by setting the <code>FDMOD</code> bit in the <code>GUSBCFG</code> register.</li>
<li>Start the PHY via <a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#a59f81a6b799e1b8481602ee15bf7d49a" title="Stops the USB PHY.">startPhy</a>.</li>
<li>Start the Transceiver via <a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#a3756904e729296d837da0a82e7bd0950" title="Starts the USB Transceiver.">startTransceiver</a>.</li>
<li>Flush the Rx FIFO via <a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#a57cd0acffdb9f21dbf95a9c56334b169" title="Flushes the Rx FIFO.">flushRxFifo</a></li>
<li>Flush all Tx FIFOs via <a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#a848efcb58b2d2687f61d17c059d7b7fc" title="Flushes a given Tx FIFO.">flushTxFifo</a></li>
<li><p class="startli">Set up the Rx FIFO Size via <a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#af68bca9f4fedfd8c6e6c0db0ef68e32c" title="Set-up the Rx FIFO Size.">setRxFifoSz</a></p>
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000007">Bug:</a></b></dt><dd>USB Host Mode (<a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#a461d8dd2f092d389b0b73da49968121da453ab40babc04abeb78339d85188e445" title="USB Host Mode.">e_UsbHost</a>) is not yet supported.</dd></dl>
</li>
</ul>

</div>
</div>
<a id="a1e3ab532f29e7fbd2012726a0230585a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e3ab532f29e7fbd2012726a0230585a">&#9670;&nbsp;</a></span>setupTxFifo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void usb::stm32f4::UsbCoreViaSTM32F4::setupTxFifo </td>
          <td>(</td>
          <td class="paramtype">const unsigned&#160;</td>
          <td class="paramname"><em>p_endpoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>p_fifoSzInWords</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set up the Tx FIFO for a given endpoint. </p>
<p>Sets up the Tx FIFO for a given endpoint.</p>
<dl class="section warning"><dt>Warning</dt><dd>Please note that there is currently no check on the FIFO sizes of all Endpoints. I.e. the FIFO sizes can be requested such that the total amount of all enpoint FIFOs exceeds the hardware capabilities.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_endpoint</td><td>IN Endpoint Number whose FIFO is to be set up. </td></tr>
    <tr><td class="paramname">p_fifoSzInWords</td><td>Endpoint's Tx FIFO Size in Words. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5eb52418a457e201740d6ed9dec5e6ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5eb52418a457e201740d6ed9dec5e6ed">&#9670;&nbsp;</a></span>setUsbTurnAroundTime()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void usb::stm32f4::UsbCoreViaSTM32F4::setUsbTurnAroundTime </td>
          <td>(</td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>p_turnaroundTime</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the USB Turn Around Time. </p>
<p>Sets the USB Turnsaround time <code>TRDT</code> in Register <code>GUSBCFG</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_turnaroundTime</td><td>Turnaround time in PHY Clocks. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a879effe6fc9a6d31dceaff31cb1a3742"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a879effe6fc9a6d31dceaff31cb1a3742">&#9670;&nbsp;</a></span>start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void usb::stm32f4::UsbCoreViaSTM32F4::start </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts the USB Core. </p>
<p>Starts the USB Core Operation by:</p>
<ul>
<li>Starting the PHY.</li>
<li>Starting the USB Transceiver.</li>
<li>Enabling the IRQ.</li>
</ul>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#ad126dd9920c327a10e2acfec238cb165" title="Stops the USB Core.">stop</a> </dd></dl>

</div>
</div>
<a id="a59f81a6b799e1b8481602ee15bf7d49a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59f81a6b799e1b8481602ee15bf7d49a">&#9670;&nbsp;</a></span>startPhy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void usb::stm32f4::UsbCoreViaSTM32F4::startPhy </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stops the USB PHY. </p>
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000003">Bug:</a></b></dt><dd>This method essentially does the same thing as <a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#a13dcc6cce6f7e58b1c33746878267060" title="Resumes the USB PHY.">resumePhy</a>.</dd></dl>

</div>
</div>
<a id="a3756904e729296d837da0a82e7bd0950"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3756904e729296d837da0a82e7bd0950">&#9670;&nbsp;</a></span>startTransceiver()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void usb::stm32f4::UsbCoreViaSTM32F4::startTransceiver </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Starts the USB Transceiver. </p>
<p>Starts the USB Transceiver by setting the <code>PWRDWN</code> bit in the <code>GCCFG</code> register. </p>

</div>
</div>
<a id="ad126dd9920c327a10e2acfec238cb165"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad126dd9920c327a10e2acfec238cb165">&#9670;&nbsp;</a></span>stop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void usb::stm32f4::UsbCoreViaSTM32F4::stop </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stops the USB Core. </p>
<p>Stops the USB Core by</p><ul>
<li>Stopping the Transceiver.</li>
<li>Stopping the PHY.</li>
</ul>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#a879effe6fc9a6d31dceaff31cb1a3742" title="Starts the USB Core.">start</a> </dd></dl>

</div>
</div>
<a id="a4576695f77ce72c047432c64f6578031"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4576695f77ce72c047432c64f6578031">&#9670;&nbsp;</a></span>stopPhy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void usb::stm32f4::UsbCoreViaSTM32F4::stopPhy </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stops the USB PHY. </p>
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000006">Bug:</a></b></dt><dd>This method essentially does the same thing as <a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#af1c7fbbc13b1298102692d8793a78dbc" title="Suspends the USB PHY.">suspendPhy</a>.</dd></dl>

</div>
</div>
<a id="a4ba1c5a2bcb9cd300b2b5db66c888831"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ba1c5a2bcb9cd300b2b5db66c888831">&#9670;&nbsp;</a></span>stopTransceiver()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void usb::stm32f4::UsbCoreViaSTM32F4::stopTransceiver </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stops the USB Transceiver. </p>
<p>Stops the USB Transceiver by clearing the <code>PWRDWN</code> bit in the <code>GCCFG</code> register. </p>

</div>
</div>
<a id="af1c7fbbc13b1298102692d8793a78dbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1c7fbbc13b1298102692d8793a78dbc">&#9670;&nbsp;</a></span>suspendPhy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void usb::stm32f4::UsbCoreViaSTM32F4::suspendPhy </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Suspends the USB PHY. </p>
<p>Suspends the USB PHY by disabling the clocks via the <code>PCGCCTL</code> register.</p><ul>
<li>Stops the PHY 48 MHz Clock (<code>STPPCLK</code> Bit). This will shut off most hardware logic except the resume / remote wake-up capabilities.</li>
<li>Gates the HCLK (<code>GATEHCLK</code> Bit). This will shut down all hardware logic except the register read / write interface.</li>
</ul>
<dl class="section attention"><dt>Attention</dt><dd>This method blocks until the Hardware reports the PHY as actually suspended via the <code>PCGCCTL</code> register.</dd></dl>
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000005">Bug:</a></b></dt><dd>I think the <code>STPPCLK</code> and the <code>GATEHCLK</code> should be separated as only the <code>STPPCLK</code> bit should be set when a <em>USB Suspend</em> IRQ ( <a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#a1e49824b11b06f37955e30a72ccc2137a87a77f40e07c5491a25b02e50a839f95" title="USB Suspend IRQ.">e_Suspend</a> ) occurs.</dd></dl>

</div>
</div>
<a id="a725cea85a05155fdde94de98fb148421"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a725cea85a05155fdde94de98fb148421">&#9670;&nbsp;</a></span>terminate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void usb::stm32f4::UsbCoreViaSTM32F4::terminate </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Terminate the USB Core. </p>
<p>This method will reset the Hardware by calling <a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#a27ee8785d34bcdfd8baa4ece56cc2118" title="Resets the USB Core.">reset</a> internally. </p>

</div>
</div>
<a id="a10801276926fdbe30bc6e19edf021ca7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10801276926fdbe30bc6e19edf021ca7">&#9670;&nbsp;</a></span>unregisterDevice()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void usb::stm32f4::UsbCoreViaSTM32F4::unregisterDevice </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unregister USB Device Mode specific Callback Object. </p>
<p>This method is only allowed to be called if if an object has been registered before.</p>
<p>While this would not be required, the pattern is used to discourage calls that would not be needed otherwise.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_device</td><td><a class="el" href="classusb_1_1stm32f4_1_1_usb_device_via_s_t_m32_f4.html">UsbDeviceViaSTM32F4</a> be unregistered as a callback.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#ac2f5988fbb4bc8037d6e647c0ad621dc" title="Register USB Device Mode specific Callback Object.">registerDevice</a> </dd></dl>

</div>
</div>
<a id="ab1ecb4f63a2f8c68f00983b0458f1b43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1ecb4f63a2f8c68f00983b0458f1b43">&#9670;&nbsp;</a></span>wakeUpDetectedIrq()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void usb::stm32f4::UsbCoreViaSTM32F4::wakeUpDetectedIrq </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handle the <em>Wake-up Detected</em> IRQ. </p>
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000008">Bug:</a></b></dt><dd>From the Datasheed it seems this is the complement to the <em>USB Suspend</em> IRQ (<a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#a1e49824b11b06f37955e30a72ccc2137a87a77f40e07c5491a25b02e50a839f95" title="USB Suspend IRQ.">e_Suspend</a>). We should probably call <a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#a13dcc6cce6f7e58b1c33746878267060" title="Resumes the USB PHY.">resumePhy</a> here.</dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a7dc7042ac84afd01fb3143696a203efa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dc7042ac84afd01fb3143696a203efa">&#9670;&nbsp;</a></span>m_irq_handler</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#a8544f1184ec6c16d2a645c6c5228e41d">UsbCoreViaSTM32F4::irq_handler_t</a> usb::stm32f4::UsbCoreViaSTM32F4::m_irq_handler</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div>
<div class="line">    { USB_OTG_GINTSTS_SRQINT,   &amp;<a class="code" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#a5061e18cc35db5fa85a8b421db06256e">UsbCoreViaSTM32F4::handleSessionRequest</a> },</div>
<div class="line">    { USB_OTG_GINTSTS_MMIS,     &amp;<a class="code" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#a9d8f2df39c69f1a59242eb537b4c0714">UsbCoreViaSTM32F4::handleModeMismatchIrq</a> },</div>
<div class="line">    { USB_OTG_GINTSTS_OTGINT,   &amp;<a class="code" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#a3a6ed2d364d4e3653db2d10847aa098f">UsbCoreViaSTM32F4::handleOtgIrq</a> },</div>
<div class="line">    { USB_OTG_GINTSTS_WKUINT,   &amp;<a class="code" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#ab1ecb4f63a2f8c68f00983b0458f1b43">UsbCoreViaSTM32F4::wakeUpDetectedIrq</a> },</div>
<div class="line">    { 0, NULL }</div>
<div class="line">}</div>
</div><!-- fragment -->
<p>USB Core Interrupt Handlers. </p>
<p>Table of interrupt handlers. Is handled in order from first to last, i.e. functions listed earlier are handled before the functions listed later.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#a58929cd04b43a5450a6b633dd2953812" title="USB Core Interrupt Handler.">handleIrq</a> </dd></dl>

</div>
</div>
<a id="a358f93ffcad0f759452778f91ff516af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a358f93ffcad0f759452778f91ff516af">&#9670;&nbsp;</a></span>m_otgirq_handler</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#a8544f1184ec6c16d2a645c6c5228e41d">UsbCoreViaSTM32F4::irq_handler_t</a> usb::stm32f4::UsbCoreViaSTM32F4::m_otgirq_handler</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div>
<div class="line">    { USB_OTG_GOTGINT_SEDET,    &amp;<a class="code" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#a7167cab2124f0f210442c42ae94c2d63">UsbCoreViaSTM32F4::handleSessionEnd</a> },</div>
<div class="line">    { 0, NULL }</div>
<div class="line">}</div>
</div><!-- fragment -->
<p>USB Core On-the-Go (OTG) Interrupt Handlers. </p>
<p>Table of On-the-Go (OTG) interrupt handlers. Is handled in order from first to last, i.e. functions listed earlier are handled before the functions listed later.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#a3a6ed2d364d4e3653db2d10847aa098f" title="USB Core On-the-Go (OTG) Interrupt Handler.">handleOtgIrq</a> </dd></dl>

</div>
</div>
<a id="a3e2241f87f7136e1bc5551a55e8aedc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e2241f87f7136e1bc5551a55e8aedc8">&#9670;&nbsp;</a></span>m_rxFifoSzInWords</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const uint32_t usb::stm32f4::UsbCoreViaSTM32F4::m_rxFifoSzInWords</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>USB Rx FIFO Size in Words. </p>
<p>Used to set up the <code>GRXFSIZ</code> register when the hardware is configured.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#af68bca9f4fedfd8c6e6c0db0ef68e32c" title="Set-up the Rx FIFO Size.">setRxFifoSz</a> </dd></dl>

</div>
</div>
<a id="a59baddb474530bb2cab74214fb8049eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59baddb474530bb2cab74214fb8049eb">&#9670;&nbsp;</a></span>m_usbPwrCtrl</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#af6f22e2b93106289c2760f3a88e7e2a7">PowerAndClockGatingControl_t</a>* const usb::stm32f4::UsbCoreViaSTM32F4::m_usbPwrCtrl</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reference to the USB Core's <code>PCGCCTL</code> Register. </p>
<p>This register allows control of the USB Clocks, most importantly the PHY.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#a59f81a6b799e1b8481602ee15bf7d49a" title="Stops the USB PHY.">startPhy</a> </dd>
<dd>
<a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#a4576695f77ce72c047432c64f6578031" title="Stops the USB PHY.">stopPhy</a> </dd>
<dd>
<a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#af1c7fbbc13b1298102692d8793a78dbc" title="Suspends the USB PHY.">suspendPhy</a> </dd>
<dd>
<a class="el" href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#a13dcc6cce6f7e58b1c33746878267060" title="Resumes the USB PHY.">resumePhy</a> </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>common/stm32f4/usb/include/usb/<a class="el" href="_usb_core_via_s_t_m32_f4_8hpp_source.html">UsbCoreViaSTM32F4.hpp</a></li>
<li>common/stm32f4/usb/UsbCoreViaSTM32F4.cpp</li>
</ul>
</div><!-- contents -->
<div class="ttc" id="aclassusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4_html_a5061e18cc35db5fa85a8b421db06256e"><div class="ttname"><a href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#a5061e18cc35db5fa85a8b421db06256e">usb::stm32f4::UsbCoreViaSTM32F4::handleSessionRequest</a></div><div class="ttdeci">void handleSessionRequest(void) const</div><div class="ttdoc">Handle the Session Request IRQ.</div><div class="ttdef"><b>Definition:</b> UsbCoreViaSTM32F4.cpp:415</div></div>
<div class="ttc" id="aclassusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4_html_a9d8f2df39c69f1a59242eb537b4c0714"><div class="ttname"><a href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#a9d8f2df39c69f1a59242eb537b4c0714">usb::stm32f4::UsbCoreViaSTM32F4::handleModeMismatchIrq</a></div><div class="ttdeci">void handleModeMismatchIrq(void) const</div><div class="ttdoc">Handle the USB Mode Mismatch IRQ.</div><div class="ttdef"><b>Definition:</b> UsbCoreViaSTM32F4.cpp:389</div></div>
<div class="ttc" id="aclassusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4_html_ab1ecb4f63a2f8c68f00983b0458f1b43"><div class="ttname"><a href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#ab1ecb4f63a2f8c68f00983b0458f1b43">usb::stm32f4::UsbCoreViaSTM32F4::wakeUpDetectedIrq</a></div><div class="ttdeci">void wakeUpDetectedIrq(void) const</div><div class="ttdoc">Handle the Wake-up Detected IRQ.</div><div class="ttdef"><b>Definition:</b> UsbCoreViaSTM32F4.cpp:400</div></div>
<div class="ttc" id="aclassusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4_html_a3a6ed2d364d4e3653db2d10847aa098f"><div class="ttname"><a href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#a3a6ed2d364d4e3653db2d10847aa098f">usb::stm32f4::UsbCoreViaSTM32F4::handleOtgIrq</a></div><div class="ttdeci">void handleOtgIrq(void) const</div><div class="ttdoc">USB Core On-the-Go (OTG) Interrupt Handler.</div><div class="ttdef"><b>Definition:</b> UsbCoreViaSTM32F4.cpp:364</div></div>
<div class="ttc" id="aclassusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4_html_a7167cab2124f0f210442c42ae94c2d63"><div class="ttname"><a href="classusb_1_1stm32f4_1_1_usb_core_via_s_t_m32_f4.html#a7167cab2124f0f210442c42ae94c2d63">usb::stm32f4::UsbCoreViaSTM32F4::handleSessionEnd</a></div><div class="ttdeci">void handleSessionEnd(void) const</div><div class="ttdoc">Handle the Session End IRQ.</div><div class="ttdef"><b>Definition:</b> UsbCoreViaSTM32F4.cpp:324</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
